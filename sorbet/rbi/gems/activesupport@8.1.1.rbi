# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activesupport` gem.
# Please instead update this file by running `bin/tapioca gem activesupport`.


# :include: ../README.rdoc
#
# source://activesupport//lib/active_support/concern.rb#3
module ActiveSupport; end

# source://activesupport//lib/active_support/class_attribute.rb#4
module ActiveSupport::ClassAttribute
  class << self
    # source://activesupport//lib/active_support/class_attribute.rb#6
    def redefine(owner, name, namespaced_name, value); end

    # source://activesupport//lib/active_support/class_attribute.rb#26
    def redefine_method(owner, name, private: T.unsafe(nil), &block); end
  end
end

# = Active Support \Concern
#
# A typical module looks like this:
#
#   module M
#     def self.included(base)
#       base.extend ClassMethods
#       base.class_eval do
#         scope :disabled, -> { where(disabled: true) }
#       end
#     end
#
#     module ClassMethods
#       ...
#     end
#   end
#
# By using +ActiveSupport::Concern+ the above module could instead be
# written as:
#
#   require "active_support/concern"
#
#   module M
#     extend ActiveSupport::Concern
#
#     included do
#       scope :disabled, -> { where(disabled: true) }
#     end
#
#     class_methods do
#       ...
#     end
#   end
#
# Moreover, it gracefully handles module dependencies. Given a +Foo+ module
# and a +Bar+ module which depends on the former, we would typically write the
# following:
#
#   module Foo
#     def self.included(base)
#       base.class_eval do
#         def self.method_injected_by_foo
#           ...
#         end
#       end
#     end
#   end
#
#   module Bar
#     def self.included(base)
#       base.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Foo # We need to include this dependency for Bar
#     include Bar # Bar is the module that Host really needs
#   end
#
# But why should +Host+ care about +Bar+'s dependencies, namely +Foo+? We
# could try to hide these from +Host+ directly including +Foo+ in +Bar+:
#
#   module Bar
#     include Foo
#     def self.included(base)
#       base.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Bar
#   end
#
# Unfortunately this won't work, since when +Foo+ is included, its <tt>base</tt>
# is the +Bar+ module, not the +Host+ class. With +ActiveSupport::Concern+,
# module dependencies are properly resolved:
#
#   require "active_support/concern"
#
#   module Foo
#     extend ActiveSupport::Concern
#     included do
#       def self.method_injected_by_foo
#         ...
#       end
#     end
#   end
#
#   module Bar
#     extend ActiveSupport::Concern
#     include Foo
#
#     included do
#       self.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Bar # It works, now Bar takes care of its dependencies
#   end
#
# === Prepending concerns
#
# Just like <tt>include</tt>, concerns also support <tt>prepend</tt> with a corresponding
# <tt>prepended do</tt> callback. <tt>module ClassMethods</tt> or <tt>class_methods do</tt> are
# prepended as well.
#
# <tt>prepend</tt> is also used for any dependencies.
#
# source://activesupport//lib/active_support/concern.rb#112
module ActiveSupport::Concern
  # source://activesupport//lib/active_support/concern.rb#129
  def append_features(base); end

  # Define class methods from given block.
  # You can define private class methods as well.
  #
  #   module Example
  #     extend ActiveSupport::Concern
  #
  #     class_methods do
  #       def foo; puts 'foo'; end
  #
  #       private
  #         def bar; puts 'bar'; end
  #     end
  #   end
  #
  #   class Buzz
  #     include Example
  #   end
  #
  #   Buzz.foo # => "foo"
  #   Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)
  #
  # source://activesupport//lib/active_support/concern.rb#209
  def class_methods(&class_methods_module_definition); end

  # Evaluate given block in context of base class,
  # so that you can write class macros here.
  # When you define more than one +included+ block, it raises an exception.
  #
  # source://activesupport//lib/active_support/concern.rb#158
  def included(base = T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/concern.rb#142
  def prepend_features(base); end

  # Evaluate given block in context of base class,
  # so that you can write class macros here.
  # When you define more than one +prepended+ block, it raises an exception.
  #
  # source://activesupport//lib/active_support/concern.rb#175
  def prepended(base = T.unsafe(nil), &block); end

  class << self
    # source://activesupport//lib/active_support/concern.rb#125
    def extended(base); end
  end
end

# source://activesupport//lib/active_support/concern.rb#113
class ActiveSupport::Concern::MultipleIncludedBlocks < ::StandardError
  # @return [MultipleIncludedBlocks] a new instance of MultipleIncludedBlocks
  #
  # source://activesupport//lib/active_support/concern.rb#114
  def initialize; end
end

# source://activesupport//lib/active_support/concern.rb#119
class ActiveSupport::Concern::MultiplePrependBlocks < ::StandardError
  # @return [MultiplePrependBlocks] a new instance of MultiplePrependBlocks
  #
  # source://activesupport//lib/active_support/concern.rb#120
  def initialize; end
end

# Provides +deep_merge+ and +deep_merge!+ methods. Expects the including class
# to provide a <tt>merge!(other, &block)</tt> method.
#
# source://activesupport//lib/active_support/deep_mergeable.rb#6
module ActiveSupport::DeepMergeable
  # Returns a new instance with the values from +other+ merged recursively.
  #
  #   class Hash
  #     include ActiveSupport::DeepMergeable
  #   end
  #
  #   hash_1 = { a: true, b: { c: [1, 2, 3] } }
  #   hash_2 = { a: false, b: { x: [3, 4, 5] } }
  #
  #   hash_1.deep_merge(hash_2)
  #   # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
  #
  # A block can be provided to merge non-<tt>DeepMergeable</tt> values:
  #
  #   hash_1 = { a: 100, b: 200, c: { c1: 100 } }
  #   hash_2 = { b: 250, c: { c1: 200 } }
  #
  #   hash_1.deep_merge(hash_2) do |key, this_val, other_val|
  #     this_val + other_val
  #   end
  #   # => { a: 100, b: 450, c: { c1: 300 } }
  #
  # source://activesupport//lib/active_support/deep_mergeable.rb#29
  def deep_merge(other, &block); end

  # Same as #deep_merge, but modifies +self+.
  #
  # source://activesupport//lib/active_support/deep_mergeable.rb#34
  def deep_merge!(other, &block); end

  # Returns true if +other+ can be deep merged into +self+. Classes may
  # override this method to restrict or expand the domain of deep mergeable
  # values. Defaults to checking that +other+ is of type +self.class+.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/deep_mergeable.rb#49
  def deep_merge?(other); end
end

# source://activesupport//lib/active_support/delegation.rb#14
module ActiveSupport::Delegation
  class << self
    # source://activesupport//lib/active_support/delegation.rb#21
    def generate(owner, methods, location: T.unsafe(nil), to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), nilable: T.unsafe(nil), private: T.unsafe(nil), as: T.unsafe(nil), signature: T.unsafe(nil)); end

    # source://activesupport//lib/active_support/delegation.rb#150
    def generate_method_missing(owner, target, allow_nil: T.unsafe(nil)); end
  end
end

# source://activesupport//lib/active_support/delegation.rb#18
ActiveSupport::Delegation::RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)

# source://activesupport//lib/active_support/delegation.rb#15
ActiveSupport::Delegation::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

# Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+
# option is not used.
#
# source://activesupport//lib/active_support/delegation.rb#6
class ActiveSupport::DelegationError < ::NoMethodError
  class << self
    # source://activesupport//lib/active_support/delegation.rb#8
    def nil_target(method_name, target); end
  end
end

# = Active Support \Deprecation
#
# \Deprecation specifies the API used by \Rails to deprecate methods, instance variables, objects, and constants. It's
# also available for gems or applications.
#
# For a gem, use Deprecation.new to create a Deprecation object and store it in your module or class (in order for
# users to be able to configure it).
#
#   module MyLibrary
#     def self.deprecator
#       @deprecator ||= ActiveSupport::Deprecation.new("2.0", "MyLibrary")
#     end
#   end
#
# For a Railtie or Engine, you may also want to add it to the application's deprecators, so that the application's
# configuration can be applied to it.
#
#   module MyLibrary
#     class Railtie < Rails::Railtie
#       initializer "my_library.deprecator" do |app|
#         app.deprecators[:my_library] = MyLibrary.deprecator
#       end
#     end
#   end
#
# With the above initializer, configuration settings like the following will affect +MyLibrary.deprecator+:
#
#   # in config/environments/test.rb
#   config.active_support.deprecation = :raise
#
# source://activesupport//lib/active_support/deprecation.rb#33
class ActiveSupport::Deprecation
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::Disallowed
  include ::ActiveSupport::Deprecation::MethodWrapper

  # It accepts two parameters on initialization. The first is a version of library
  # and the second is a library name.
  #
  #   ActiveSupport::Deprecation.new('2.0', 'MyLibrary')
  #
  # @return [Deprecation] a new instance of Deprecation
  #
  # source://activesupport//lib/active_support/deprecation.rb#71
  def initialize(deprecation_horizon = T.unsafe(nil), gem_name = T.unsafe(nil)); end

  # The version number in which the deprecated behavior will be removed, by default.
  #
  # source://activesupport//lib/active_support/deprecation.rb#65
  def deprecation_horizon; end

  # The version number in which the deprecated behavior will be removed, by default.
  #
  # source://activesupport//lib/active_support/deprecation.rb#65
  def deprecation_horizon=(_arg0); end

  class << self
    # source://activesupport//lib/active_support/deprecation.rb#60
    def _instance; end
  end
end

# Behavior module allows to determine how to display deprecation messages.
# You can create a custom behavior or set any from the +DEFAULT_BEHAVIORS+
# constant. Available behaviors are:
#
# [+:raise+]   Raise ActiveSupport::DeprecationException.
# [+:stderr+]  Log all deprecation warnings to <tt>$stderr</tt>.
# [+:log+]     Log all deprecation warnings to +Rails.logger+.
# [+:notify+]  Use ActiveSupport::Notifications to notify +deprecation.rails+.
# [+:report+]  Use ActiveSupport::ErrorReporter to report deprecations.
# [+:silence+] Do nothing. On \Rails, set <tt>config.active_support.report_deprecations = false</tt> to disable all behaviors.
#
# Setting behaviors only affects deprecations that happen after boot time.
# For more information you can read the documentation of the #behavior= method.
#
# source://activesupport//lib/active_support/deprecation/behaviors.rb#69
module ActiveSupport::Deprecation::Behavior
  # Returns the current behavior or if one isn't set, defaults to +:stderr+.
  #
  # source://activesupport//lib/active_support/deprecation/behaviors.rb#74
  def behavior; end

  # Sets the behavior to the specified value. Can be a single value, array,
  # or an object that responds to +call+.
  #
  # Available behaviors:
  #
  # [+:raise+]   Raise ActiveSupport::DeprecationException.
  # [+:stderr+]  Log all deprecation warnings to <tt>$stderr</tt>.
  # [+:log+]     Log all deprecation warnings to +Rails.logger+.
  # [+:notify+]  Use ActiveSupport::Notifications to notify +deprecation.rails+.
  # [+:report+]  Use ActiveSupport::ErrorReporter to report deprecations.
  # [+:silence+] Do nothing.
  #
  # Setting behaviors only affects deprecations that happen after boot time.
  # Deprecation warnings raised by gems are not affected by this setting
  # because they happen before \Rails boots up.
  #
  #   deprecator = ActiveSupport::Deprecation.new
  #   deprecator.behavior = :stderr
  #   deprecator.behavior = [:stderr, :log]
  #   deprecator.behavior = MyCustomHandler
  #   deprecator.behavior = ->(message, callstack, deprecation_horizon, gem_name) {
  #     # custom stuff
  #   }
  #
  # If you are using \Rails, you can set
  # <tt>config.active_support.report_deprecations = false</tt> to disable
  # all deprecation behaviors. This is similar to the +:silence+ option but
  # more performant.
  #
  # source://activesupport//lib/active_support/deprecation/behaviors.rb#111
  def behavior=(behavior); end

  # Whether to print a backtrace along with the warning.
  #
  # source://activesupport//lib/active_support/deprecation/behaviors.rb#71
  def debug; end

  # Whether to print a backtrace along with the warning.
  #
  # source://activesupport//lib/active_support/deprecation/behaviors.rb#71
  def debug=(_arg0); end

  # Returns the current behavior for disallowed deprecations or if one isn't set, defaults to +:raise+.
  #
  # source://activesupport//lib/active_support/deprecation/behaviors.rb#79
  def disallowed_behavior; end

  # Sets the behavior for disallowed deprecations (those configured by
  # ActiveSupport::Deprecation#disallowed_warnings=) to the specified
  # value. As with #behavior=, this can be a single value, array, or an
  # object that responds to +call+.
  #
  # source://activesupport//lib/active_support/deprecation/behaviors.rb#119
  def disallowed_behavior=(behavior); end

  private

  # source://activesupport//lib/active_support/deprecation/behaviors.rb#124
  def arity_coerce(behavior); end

  # source://activesupport//lib/active_support/deprecation/behaviors.rb#143
  def arity_of_callable(callable); end
end

# Default warning behaviors per Rails.env.
#
# source://activesupport//lib/active_support/deprecation/behaviors.rb#13
ActiveSupport::Deprecation::DEFAULT_BEHAVIORS = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/deprecation/constant_accessor.rb#5
module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  class << self
    # @private
    #
    # source://activesupport//lib/active_support/deprecation/constant_accessor.rb#6
    def included(base); end
  end
end

# DeprecatedConstantProxy transforms a constant into a deprecated one. It takes the full names of an old
# (deprecated) constant and of a new constant (both in string form) and a deprecator. The deprecated constant now
# returns the value of the new one.
#
#   PLANETS = %w(mercury venus earth mars jupiter saturn uranus neptune pluto)
#
#   # (In a later update, the original implementation of `PLANETS` has been removed.)
#
#   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
#   PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new("PLANETS", "PLANETS_POST_2006", ActiveSupport::Deprecation.new)
#
#   PLANETS.map { |planet| planet.capitalize }
#   # => DEPRECATION WARNING: PLANETS is deprecated! Use PLANETS_POST_2006 instead.
#        (Backtrace information…)
#        ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
#
# source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#120
class ActiveSupport::Deprecation::DeprecatedConstantProxy < ::Module
  # @return [DeprecatedConstantProxy] a new instance of DeprecatedConstantProxy
  #
  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#128
  def initialize(old_const, new_const, deprecator, message: T.unsafe(nil)); end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#158
  def append_features(base); end

  # Returns the class of the new constant.
  #
  #   PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune)
  #   PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('PLANETS', 'PLANETS_POST_2006')
  #   PLANETS.class # => Array
  #
  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#154
  def class; end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#168
  def extended(base); end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#147
  def hash(*_arg0, **_arg1, &_arg2); end

  # Don't give a deprecation warning on inspect since test/unit and error
  # logs rely on it for diagnostics.
  #
  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#141
  def inspect; end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#147
  def instance_methods(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#147
  def name(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#163
  def prepend_features(base); end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#147
  def respond_to?(*_arg0, **_arg1, &_arg2); end

  private

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#178
  def const_missing(name); end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#183
  def method_missing(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#174
  def target; end

  class << self
    # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#121
    def new(*args, **options, &block); end
  end
end

# DeprecatedInstanceVariableProxy transforms an instance variable into a deprecated one. It takes an instance of a
# class, a method on that class, an instance variable, and a deprecator as the last argument.
#
# Trying to use the deprecated instance variable will result in a deprecation warning, pointing to the method as a
# replacement.
#
#   class Example
#     def initialize
#       @request = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(self, :request, :@request, ActiveSupport::Deprecation.new)
#       @_request = :special_request
#     end
#
#     def request
#       @_request
#     end
#
#     def old_request
#       @request
#     end
#   end
#
#   example = Example.new
#   # => #<Example:0x007fb9b31090b8 @_request=:special_request, @request=:special_request>
#
#   example.old_request.to_s
#   # => DEPRECATION WARNING: @request is deprecated! Call request.to_s instead of
#      @request.to_s
#      (Backtrace information…)
#      "special_request"
#
#   example.request.to_s
#   # => "special_request"
#
# source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#87
class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy < ::ActiveSupport::Deprecation::DeprecationProxy
  # @return [DeprecatedInstanceVariableProxy] a new instance of DeprecatedInstanceVariableProxy
  #
  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#88
  def initialize(instance, method, var = T.unsafe(nil), deprecator:); end

  private

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#96
  def target; end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#100
  def warn(callstack, called, args); end
end

# DeprecatedObjectProxy transforms an object into a deprecated one. It takes an object, a deprecation message, and
# a deprecator.
#
#   deprecated_object = ActiveSupport::Deprecation::DeprecatedObjectProxy.new(Object.new, "This object is now deprecated", ActiveSupport::Deprecation.new)
#   # => #<Object:0x007fb9b34c34b0>
#
#   deprecated_object.to_s
#   DEPRECATION WARNING: This object is now deprecated.
#   (Backtrace)
#   # => "#<Object:0x007fb9b34c34b0>"
#
# source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#38
class ActiveSupport::Deprecation::DeprecatedObjectProxy < ::ActiveSupport::Deprecation::DeprecationProxy
  # @return [DeprecatedObjectProxy] a new instance of DeprecatedObjectProxy
  #
  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#39
  def initialize(object, message, deprecator); end

  private

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#46
  def target; end

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#50
  def warn(callstack, called, args); end
end

# source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#5
class ActiveSupport::Deprecation::DeprecationProxy
  # Don't give a deprecation warning on inspect since test/unit and error
  # logs rely on it for diagnostics.
  #
  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#17
  def inspect; end

  private

  # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#22
  def method_missing(called, *args, &block); end

  class << self
    # source://activesupport//lib/active_support/deprecation/proxy_wrappers.rb#6
    def new(*args, **kwargs, &block); end
  end
end

# A managed collection of deprecators. Configuration methods, such as
# #behavior=, affect all deprecators in the collection. Additionally, the
# #silence method silences all deprecators in the collection for the
# duration of a given block.
#
# source://activesupport//lib/active_support/deprecation/deprecators.rb#9
class ActiveSupport::Deprecation::Deprecators
  # @return [Deprecators] a new instance of Deprecators
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#10
  def initialize; end

  # Returns a deprecator added to this collection via #[]=.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#16
  def [](name); end

  # Adds a given +deprecator+ to this collection. The deprecator will be
  # immediately configured with any options previously set on this
  # collection.
  #
  #   deprecators = ActiveSupport::Deprecation::Deprecators.new
  #   deprecators.debug = true
  #
  #   foo_deprecator = ActiveSupport::Deprecation.new("2.0", "Foo")
  #   foo_deprecator.debug    # => false
  #
  #   deprecators[:foo] = foo_deprecator
  #   deprecators[:foo].debug # => true
  #   foo_deprecator.debug    # => true
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#34
  def []=(name, deprecator); end

  # Sets the deprecation warning behavior for all deprecators in this
  # collection.
  #
  # See ActiveSupport::Deprecation#behavior=.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#60
  def behavior=(behavior); end

  # Sets the debug flag for all deprecators in this collection.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#52
  def debug=(debug); end

  # Sets the disallowed deprecation warning behavior for all deprecators in
  # this collection.
  #
  # See ActiveSupport::Deprecation#disallowed_behavior=.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#68
  def disallowed_behavior=(disallowed_behavior); end

  # Sets the disallowed deprecation warnings for all deprecators in this
  # collection.
  #
  # See ActiveSupport::Deprecation#disallowed_warnings=.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#76
  def disallowed_warnings=(disallowed_warnings); end

  # Iterates over all deprecators in this collection. If no block is given,
  # returns an +Enumerator+.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#41
  def each(&block); end

  # Silences all deprecators in this collection for the duration of the
  # given block.
  #
  # See ActiveSupport::Deprecation#silence.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#84
  def silence(&block); end

  # Sets the silenced flag for all deprecators in this collection.
  #
  # source://activesupport//lib/active_support/deprecation/deprecators.rb#47
  def silenced=(silenced); end

  private

  # source://activesupport//lib/active_support/deprecation/deprecators.rb#97
  def apply_options(deprecator); end

  # source://activesupport//lib/active_support/deprecation/deprecators.rb#92
  def set_option(name, value); end
end

# source://activesupport//lib/active_support/deprecation/disallowed.rb#5
module ActiveSupport::Deprecation::Disallowed
  # Returns the configured criteria used to identify deprecation messages
  # which should be treated as disallowed.
  #
  # source://activesupport//lib/active_support/deprecation/disallowed.rb#21
  def disallowed_warnings; end

  # Sets the criteria used to identify deprecation messages which should be
  # disallowed. Can be an array containing strings, symbols, or regular
  # expressions. (Symbols are treated as strings.) These are compared against
  # the text of the generated deprecation warning.
  #
  # Additionally the scalar symbol +:all+ may be used to treat all
  # deprecations as disallowed.
  #
  # Deprecations matching a substring or regular expression will be handled
  # using the configured Behavior#disallowed_behavior rather than
  # Behavior#behavior.
  #
  # source://activesupport//lib/active_support/deprecation/disallowed.rb#17
  def disallowed_warnings=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/deprecation/disallowed.rb#26
  def deprecation_disallowed?(message); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/deprecation/disallowed.rb#39
  def explicitly_allowed?(message); end
end

# source://activesupport//lib/active_support/deprecation.rb#57
ActiveSupport::Deprecation::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://activesupport//lib/active_support/deprecation/method_wrappers.rb#8
module ActiveSupport::Deprecation::MethodWrapper
  # Declare that a method has been deprecated.
  #
  #   class Fred
  #     def aaa; end
  #     def bbb; end
  #     def ccc; end
  #     def ddd; end
  #     def eee; end
  #   end
  #
  #   deprecator = ActiveSupport::Deprecation.new('next-release', 'MyGem')
  #
  #   deprecator.deprecate_methods(Fred, :aaa, bbb: :zzz, ccc: 'use Bar#ccc instead')
  #   # => Fred
  #
  #   Fred.new.aaa
  #   # DEPRECATION WARNING: aaa is deprecated and will be removed from MyGem next-release. (called from irb_binding at (irb):10)
  #   # => nil
  #
  #   Fred.new.bbb
  #   # DEPRECATION WARNING: bbb is deprecated and will be removed from MyGem next-release (use zzz instead). (called from irb_binding at (irb):11)
  #   # => nil
  #
  #   Fred.new.ccc
  #   # DEPRECATION WARNING: ccc is deprecated and will be removed from MyGem next-release (use Bar#ccc instead). (called from irb_binding at (irb):12)
  #   # => nil
  #
  # source://activesupport//lib/active_support/deprecation/method_wrappers.rb#35
  def deprecate_methods(target_module, *method_names); end
end

# source://activesupport//lib/active_support/deprecation/reporting.rb#7
module ActiveSupport::Deprecation::Reporting
  # Allow previously disallowed deprecation warnings within the block.
  # <tt>allowed_warnings</tt> can be an array containing strings, symbols, or regular
  # expressions. (Symbols are treated as strings). These are compared against
  # the text of deprecation warning messages generated within the block.
  # Matching warnings will be exempt from the rules set by
  # ActiveSupport::Deprecation#disallowed_warnings.
  #
  # The optional <tt>if:</tt> argument accepts a truthy/falsy value or an object that
  # responds to <tt>.call</tt>. If truthy, then matching warnings will be allowed.
  # If falsey then the method yields to the block without allowing the warning.
  #
  #   deprecator = ActiveSupport::Deprecation.new
  #   deprecator.disallowed_behavior = :raise
  #   deprecator.disallowed_warnings = [
  #     "something broke"
  #   ]
  #
  #   deprecator.warn('something broke!')
  #   # => ActiveSupport::DeprecationException
  #
  #   deprecator.allow ['something broke'] do
  #     deprecator.warn('something broke!')
  #   end
  #   # => nil
  #
  #   deprecator.allow ['something broke'], if: Rails.env.production? do
  #     deprecator.warn('something broke!')
  #   end
  #   # => ActiveSupport::DeprecationException for dev/test, nil for production
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#89
  def allow(allowed_warnings = T.unsafe(nil), if: T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/deprecation/reporting.rb#48
  def begin_silence; end

  # source://activesupport//lib/active_support/deprecation/reporting.rb#99
  def deprecation_warning(deprecated_method_name, message = T.unsafe(nil), caller_backtrace = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/deprecation/reporting.rb#52
  def end_silence; end

  # Name of gem where method is deprecated
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#11
  def gem_name; end

  # Name of gem where method is deprecated
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#11
  def gem_name=(_arg0); end

  # Silence deprecation warnings within the block.
  #
  #   deprecator = ActiveSupport::Deprecation.new
  #   deprecator.warn('something broke!')
  #   # => "DEPRECATION WARNING: something broke! (called from your_code.rb:1)"
  #
  #   deprecator.silence do
  #     deprecator.warn('something broke!')
  #   end
  #   # => nil
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#41
  def silence(&block); end

  # source://activesupport//lib/active_support/deprecation/reporting.rb#56
  def silenced; end

  # Whether to print a message (silent mode)
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#9
  def silenced=(_arg0); end

  # Outputs a deprecation warning to the output configured by
  # ActiveSupport::Deprecation#behavior.
  #
  #   ActiveSupport::Deprecation.new.warn('something broke!')
  #   # => "DEPRECATION WARNING: something broke! (called from your_code.rb:1)"
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#18
  def warn(message = T.unsafe(nil), callstack = T.unsafe(nil)); end

  private

  # Outputs a deprecation warning message
  #
  #   deprecated_method_warning(:method_name)
  #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon}"
  #   deprecated_method_warning(:method_name, :another_method)
  #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon} (use another_method instead)"
  #   deprecated_method_warning(:method_name, "Optional message")
  #   # => "method_name is deprecated and will be removed from Rails #{deprecation_horizon} (Optional message)"
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#115
  def deprecated_method_warning(method_name, message = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/deprecation/reporting.rb#129
  def deprecation_caller_message(callstack); end

  # source://activesupport//lib/active_support/deprecation/reporting.rb#124
  def deprecation_message(callstack, message = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/deprecation/reporting.rb#140
  def extract_callstack(callstack); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/deprecation/reporting.rb#157
  def ignored_callstack?(path); end
end

# source://activesupport//lib/active_support/deprecation/reporting.rb#154
ActiveSupport::Deprecation::Reporting::LIB_DIR = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/deprecation/reporting.rb#152
ActiveSupport::Deprecation::Reporting::RAILS_GEM_ROOT = T.let(T.unsafe(nil), String)

# Raised when ActiveSupport::Deprecation::Behavior#behavior is set with <tt>:raise</tt>.
# You would set <tt>:raise</tt>, as a behavior to raise errors and proactively report exceptions from deprecations.
#
# source://activesupport//lib/active_support/deprecation/behaviors.rb#8
class ActiveSupport::DeprecationException < ::StandardError; end

# = \Notifications
#
# +ActiveSupport::Notifications+ provides an instrumentation API for
# Ruby.
#
# == Instrumenters
#
# To instrument an event you just need to do:
#
#   ActiveSupport::Notifications.instrument('render', extra: :information) do
#     render plain: 'Foo'
#   end
#
# That first executes the block and then notifies all subscribers once done.
#
# In the example above +render+ is the name of the event, and the rest is called
# the _payload_. The payload is a mechanism that allows instrumenters to pass
# extra information to subscribers. Payloads consist of a hash whose contents
# are arbitrary and generally depend on the event.
#
# == Subscribers
#
# You can consume those events and the information they provide by registering
# a subscriber.
#
#   ActiveSupport::Notifications.subscribe('render') do |event|
#     event.name          # => "render"
#     event.duration      # => 10 (in milliseconds)
#     event.payload       # => { extra: :information }
#     event.allocations   # => 1826 (objects)
#   end
#
# +Event+ objects record CPU time and allocations. If you don't need this
# it's also possible to pass a block that accepts five arguments:
#
#   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
#     name    # => String, name of the event (such as 'render' from above)
#     start   # => Time, when the instrumented block started execution
#     finish  # => Time, when the instrumented block ended execution
#     id      # => String, unique ID for the instrumenter that fired the event
#     payload # => Hash, the payload
#   end
#
# Here, the +start+ and +finish+ values represent wall-clock time. If you are
# concerned about accuracy, you can register a monotonic subscriber.
#
#   ActiveSupport::Notifications.monotonic_subscribe('render') do |name, start, finish, id, payload|
#     name    # => String, name of the event (such as 'render' from above)
#     start   # => Float, monotonic time when the instrumented block started execution
#     finish  # => Float, monotonic time when the instrumented block ended execution
#     id      # => String, unique ID for the instrumenter that fired the event
#     payload # => Hash, the payload
#   end
#
# For instance, let's store all "render" events in an array:
#
#   events = []
#
#   ActiveSupport::Notifications.subscribe('render') do |event|
#     events << event
#   end
#
# That code returns right away, you are just subscribing to "render" events.
# The block is saved and will be called whenever someone instruments "render":
#
#   ActiveSupport::Notifications.instrument('render', extra: :information) do
#     render plain: 'Foo'
#   end
#
#   event = events.first
#   event.name          # => "render"
#   event.duration      # => 10 (in milliseconds)
#   event.payload       # => { extra: :information }
#   event.allocations   # => 1826 (objects)
#
# If an exception happens during that particular instrumentation the payload will
# have a key <tt>:exception</tt> with an array of two elements as value: a string with
# the name of the exception class, and the exception message.
# The <tt>:exception_object</tt> key of the payload will have the exception
# itself as the value:
#
#   event.payload[:exception]         # => ["ArgumentError", "Invalid value"]
#   event.payload[:exception_object]  # => #<ArgumentError: Invalid value>
#
# As the earlier example depicts, the class ActiveSupport::Notifications::Event
# is able to take the arguments as they come and provide an object-oriented
# interface to that data.
#
# It is also possible to pass an object which responds to <tt>call</tt> method
# as the second parameter to the <tt>subscribe</tt> method instead of a block:
#
#   module ActionController
#     class PageRequest
#       def call(name, started, finished, unique_id, payload)
#         Rails.logger.debug ['notification:', name, started, finished, unique_id, payload].join(' ')
#       end
#     end
#   end
#
#   ActiveSupport::Notifications.subscribe('process_action.action_controller', ActionController::PageRequest.new)
#
# resulting in the following output within the logs including a hash with the payload:
#
#   notification: process_action.action_controller 2012-04-13 01:08:35 +0300 2012-04-13 01:08:35 +0300 af358ed7fab884532ec7 {
#      controller: "Devise::SessionsController",
#      action: "new",
#      params: {"action"=>"new", "controller"=>"devise/sessions"},
#      format: :html,
#      method: "GET",
#      path: "/login/sign_in",
#      status: 200,
#      view_runtime: 279.3080806732178,
#      db_runtime: 40.053
#    }
#
# You can also subscribe to all events whose name matches a certain regexp:
#
#   ActiveSupport::Notifications.subscribe(/render/) do |*args|
#     ...
#   end
#
# and even pass no argument to <tt>subscribe</tt>, in which case you are subscribing
# to all events.
#
# == Temporary Subscriptions
#
# Sometimes you do not want to subscribe to an event for the entire life of
# the application. There are two ways to unsubscribe.
#
# WARNING: The instrumentation framework is designed for long-running subscribers,
# use this feature sparingly because it wipes some internal caches and that has
# a negative impact on performance.
#
# === Subscribe While a Block Runs
#
# You can subscribe to some event temporarily while some block runs. For
# example, in
#
#   callback = lambda {|event| ... }
#   ActiveSupport::Notifications.subscribed(callback, "sql.active_record") do
#     ...
#   end
#
# the callback will be called for all "sql.active_record" events instrumented
# during the execution of the block. The callback is unsubscribed automatically
# after that.
#
# To record +started+ and +finished+ values with monotonic time,
# specify the optional <tt>:monotonic</tt> option to the
# <tt>subscribed</tt> method. The <tt>:monotonic</tt> option is set
# to +false+ by default.
#
#   callback = lambda {|name, started, finished, unique_id, payload| ... }
#   ActiveSupport::Notifications.subscribed(callback, "sql.active_record", monotonic: true) do
#     ...
#   end
#
# === Manual Unsubscription
#
# The +subscribe+ method returns a subscriber object:
#
#   subscriber = ActiveSupport::Notifications.subscribe("render") do |event|
#     ...
#   end
#
# To prevent that block from being called anymore, just unsubscribe passing
# that reference:
#
#   ActiveSupport::Notifications.unsubscribe(subscriber)
#
# You can also unsubscribe by passing the name of the subscriber object. Note
# that this will unsubscribe all subscriptions with the given name:
#
#   ActiveSupport::Notifications.unsubscribe("render")
#
# Subscribers using a regexp or other pattern-matching object will remain subscribed
# to all events that match their original pattern, unless those events match a string
# passed to +unsubscribe+:
#
#   subscriber = ActiveSupport::Notifications.subscribe(/render/) { }
#   ActiveSupport::Notifications.unsubscribe('render_template.action_view')
#   subscriber.matches?('render_template.action_view') # => false
#   subscriber.matches?('render_partial.action_view') # => true
#
# == Default Queue
#
# Notifications ships with a queue implementation that consumes and publishes events
# to all log subscribers. You can use any queue implementation you want.
#
# source://activesupport//lib/active_support/notifications/instrumenter.rb#7
module ActiveSupport::Notifications
  class << self
    # source://activesupport//lib/active_support/notifications.rb#208
    def instrument(name, payload = T.unsafe(nil)); end

    # source://activesupport//lib/active_support/notifications.rb#269
    def instrumenter; end

    # Performs the same functionality as #subscribe, but the +start+ and
    # +finish+ block arguments are in monotonic time instead of wall-clock
    # time. Monotonic time will not jump forward or backward (due to NTP or
    # Daylights Savings). Use +monotonic_subscribe+ when accuracy of time
    # duration is important. For example, computing elapsed time between
    # two events.
    #
    # source://activesupport//lib/active_support/notifications.rb#254
    def monotonic_subscribe(pattern = T.unsafe(nil), callback = T.unsafe(nil), &block); end

    # Returns the value of attribute notifier.
    #
    # source://activesupport//lib/active_support/notifications.rb#198
    def notifier; end

    # Sets the attribute notifier
    #
    # @param value the value to set the attribute notifier to.
    #
    # source://activesupport//lib/active_support/notifications.rb#198
    def notifier=(_arg0); end

    # source://activesupport//lib/active_support/notifications.rb#200
    def publish(name, *args); end

    # source://activesupport//lib/active_support/notifications.rb#204
    def publish_event(event); end

    # Subscribe to a given event name with the passed +block+.
    #
    # You can subscribe to events by passing a String to match exact event
    # names, or by passing a Regexp to match all events that match a pattern.
    #
    # If the block passed to the method only takes one argument,
    # it will yield an +Event+ object to the block:
    #
    #   ActiveSupport::Notifications.subscribe(/render/) do |event|
    #     @event = event
    #   end
    #
    # Otherwise the +block+ will receive five arguments with information
    # about the event:
    #
    #   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
    #     name    # => String, name of the event (such as 'render' from above)
    #     start   # => Time, when the instrumented block started execution
    #     finish  # => Time, when the instrumented block ended execution
    #     id      # => String, unique ID for the instrumenter that fired the event
    #     payload # => Hash, the payload
    #   end
    #
    # Raises an error if invalid event name type is passed:
    #
    #   ActiveSupport::Notifications.subscribe(:render) {|event| ...}
    #   #=> ArgumentError (pattern must be specified as a String, Regexp or empty)
    #
    # source://activesupport//lib/active_support/notifications.rb#244
    def subscribe(pattern = T.unsafe(nil), callback = T.unsafe(nil), &block); end

    # source://activesupport//lib/active_support/notifications.rb#258
    def subscribed(callback, pattern = T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

    # source://activesupport//lib/active_support/notifications.rb#265
    def unsubscribe(subscriber_or_name); end

    private

    # source://activesupport//lib/active_support/notifications.rb#274
    def registry; end
  end
end

# source://activesupport//lib/active_support/notifications/instrumenter.rb#106
class ActiveSupport::Notifications::Event
  # @return [Event] a new instance of Event
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#110
  def initialize(name, start, ending, transaction_id, payload); end

  # Returns the number of allocations made between the call to #start! and
  # the call to #finish!.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#176
  def allocations; end

  # Returns the CPU time (in milliseconds) passed between the call to
  # #start! and the call to #finish!.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#163
  def cpu_time; end

  # Returns the difference in milliseconds between when the execution of the
  # event started and when it ended.
  #
  #   ActiveSupport::Notifications.subscribe('wait') do |event|
  #     @event = event
  #   end
  #
  #   ActiveSupport::Notifications.instrument('wait') do
  #     sleep 1
  #   end
  #
  #   @event.duration # => 1000.138
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#198
  def duration; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#128
  def end; end

  # Record information at the time this event finishes
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#154
  def finish!; end

  # Returns the time spent in GC (in milliseconds) between the call to #start!
  # and the call to #finish!
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#182
  def gc_time; end

  # Returns the idle time (in milliseconds) passed between the call to
  # #start! and the call to #finish!.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#169
  def idle_time; end

  # Returns the value of attribute name.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#107
  def name; end

  # Returns the value of attribute payload.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#108
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#108
  def payload=(_arg0); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#132
  def record; end

  # Record information at the time this event starts
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#146
  def start!; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#124
  def time; end

  # Returns the value of attribute transaction_id.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#107
  def transaction_id; end

  private

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#203
  def now; end

  # Likely on JRuby, TruffleRuby
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#230
  def now_allocations; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#210
  def now_cpu; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#220
  def now_gc; end
end

# This is a default queue implementation that ships with Notifications.
# It just pushes events to all registered log subscribers.
#
# This class is thread safe. All methods are reentrant.
#
# source://activesupport//lib/active_support/notifications/fanout.rb#55
class ActiveSupport::Notifications::Fanout
  include ::ActiveSupport::Notifications::FanoutIteration

  # @return [Fanout] a new instance of Fanout
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#56
  def initialize; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#319
  def all_listeners_for(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#286
  def build_handle(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#106
  def clear_cache(key = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#305
  def finish(name, id, payload, listeners = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#190
  def group_listeners(listeners); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#196
  def groups_for(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#64
  def inspect; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#328
  def listeners_for(name); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#332
  def listening?(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#311
  def publish(name, *_arg1, **_arg2, &_arg3); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#315
  def publish_event(event); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#298
  def start(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#69
  def subscribe(pattern = T.unsafe(nil), callable = T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#86
  def unsubscribe(subscriber_or_name); end

  # This is a sync queue, so there is no waiting.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#337
  def wait; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#116
class ActiveSupport::Notifications::Fanout::BaseGroup
  include ::ActiveSupport::Notifications::FanoutIteration

  # @return [BaseGroup] a new instance of BaseGroup
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#119
  def initialize(listeners, name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#123
  def each(&block); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#128
class ActiveSupport::Notifications::Fanout::BaseTimeGroup < ::ActiveSupport::Notifications::Fanout::BaseGroup
  # source://activesupport//lib/active_support/notifications/fanout.rb#133
  def finish(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#129
  def start(name, id, payload); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#169
class ActiveSupport::Notifications::Fanout::EventObjectGroup < ::ActiveSupport::Notifications::Fanout::BaseGroup
  # source://activesupport//lib/active_support/notifications/fanout.rb#175
  def finish(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#170
  def start(name, id, payload); end

  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#185
  def build_event(name, id, payload); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#155
class ActiveSupport::Notifications::Fanout::EventedGroup < ::ActiveSupport::Notifications::Fanout::BaseGroup
  # source://activesupport//lib/active_support/notifications/fanout.rb#162
  def finish(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#156
  def start(name, id, payload); end
end

# A +Handle+ is used to record the start and finish time of event.
#
# Both #start and #finish must each be called exactly once.
#
# Where possible, it's best to use the block form: ActiveSupport::Notifications.instrument.
# +Handle+ is a low-level API intended for cases where the block form can't be used.
#
#   handle = ActiveSupport::Notifications.instrumenter.build_handle("my.event", {})
#   begin
#     handle.start
#     # work to be instrumented
#   ensure
#     handle.finish
#   end
#
# source://activesupport//lib/active_support/notifications/fanout.rb#230
class ActiveSupport::Notifications::Fanout::Handle
  include ::ActiveSupport::Notifications::FanoutIteration

  # @return [Handle] a new instance of Handle
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#233
  def initialize(notifier, name, id, groups, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#250
  def finish; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#254
  def finish_with_values(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#241
  def start; end

  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#264
  def ensure_state!(expected); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#141
class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup < ::ActiveSupport::Notifications::Fanout::BaseTimeGroup
  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#143
  def now; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#271
module ActiveSupport::Notifications::Fanout::NullHandle
  extend ::ActiveSupport::Notifications::Fanout::NullHandle

  # source://activesupport//lib/active_support/notifications/fanout.rb#277
  def finish; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#280
  def finish_with_values(_name, _id, _payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#274
  def start; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#340
module ActiveSupport::Notifications::Fanout::Subscribers
  class << self
    # source://activesupport//lib/active_support/notifications/fanout.rb#341
    def new(pattern, listener, monotonic); end
  end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#455
class ActiveSupport::Notifications::Fanout::Subscribers::EventObject < ::ActiveSupport::Notifications::Fanout::Subscribers::Evented
  # source://activesupport//lib/active_support/notifications/fanout.rb#456
  def group_class; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#460
  def publish_event(event); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#397
class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  # @return [Evented] a new instance of Evented
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#400
  def initialize(pattern, delegate); end

  # Returns the value of attribute delegate.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#398
  def delegate; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#408
  def group_class; end

  # Returns the value of attribute pattern.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#398
  def pattern; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#412
  def publish(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#418
  def publish_event(event); end

  # Returns the value of attribute silenceable.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#398
  def silenceable; end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#426
  def silenced?(name); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#430
  def subscribed_to?(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#434
  def unsubscribe!(name); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#360
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  # @return [Matcher] a new instance of Matcher
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#373
  def initialize(pattern); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#382
  def ===(name); end

  # Returns the value of attribute exclusions.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#361
  def exclusions; end

  # Returns the value of attribute pattern.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#361
  def pattern; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#378
  def unsubscribe!(name); end

  class << self
    # source://activesupport//lib/active_support/notifications/fanout.rb#363
    def wrap(pattern); end
  end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#386
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
  # source://activesupport//lib/active_support/notifications/fanout.rb#387
  def ===(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#391
  def unsubscribe!(*_arg0); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#449
class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed < ::ActiveSupport::Notifications::Fanout::Subscribers::Timed
  # source://activesupport//lib/active_support/notifications/fanout.rb#450
  def group_class; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#439
class ActiveSupport::Notifications::Fanout::Subscribers::Timed < ::ActiveSupport::Notifications::Fanout::Subscribers::Evented
  # source://activesupport//lib/active_support/notifications/fanout.rb#440
  def group_class; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#444
  def publish(*_arg0, **_arg1, &_arg2); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#148
class ActiveSupport::Notifications::Fanout::TimedGroup < ::ActiveSupport::Notifications::Fanout::BaseTimeGroup
  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#150
  def now; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#18
module ActiveSupport::Notifications::FanoutIteration
  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#20
  def iterate_guarding_exceptions(collection, &block); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#8
class ActiveSupport::Notifications::InstrumentationSubscriberError < ::RuntimeError
  # @return [InstrumentationSubscriberError] a new instance of InstrumentationSubscriberError
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#11
  def initialize(exceptions); end

  # Returns the value of attribute exceptions.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#9
  def exceptions; end
end

# Instrumenters are stored in a thread local.
#
# source://activesupport//lib/active_support/notifications/instrumenter.rb#9
class ActiveSupport::Notifications::Instrumenter
  # @return [Instrumenter] a new instance of Instrumenter
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#12
  def initialize(notifier); end

  # Returns a "handle" for an event with the given +name+ and +payload+.
  #
  # #start and #finish must each be called exactly once on the returned object.
  #
  # Where possible, it's best to use #instrument, which will record the
  # start and finish of the event and correctly handle any exceptions.
  # +build_handle+ is a low-level API intended for cases where using
  # +instrument+ isn't possible.
  #
  # See ActiveSupport::Notifications::Fanout::Handle.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#78
  def build_handle(name, payload); end

  # Send a finish notification with +name+ and +payload+.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#92
  def finish(name, payload); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#96
  def finish_with_state(listeners_state, name, payload); end

  # Returns the value of attribute id.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#10
  def id; end

  # Given a block, instrument it by measuring the time taken to execute
  # and publish it. Without a block, simply send a message via the
  # notifier. Notice that events get sent even if an error occurs in the
  # passed-in block.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#54
  def instrument(name, payload = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#82
  def new_event(name, payload = T.unsafe(nil)); end

  # Send a start notification with +name+ and +payload+.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#87
  def start(name, payload); end

  private

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#101
  def unique_id; end
end

# source://activesupport//lib/active_support/notifications/instrumenter.rb#21
class ActiveSupport::Notifications::Instrumenter::LegacyHandle
  # @return [LegacyHandle] a new instance of LegacyHandle
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#34
  def initialize(notifier, name, id, payload); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#45
  def finish; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#41
  def start; end
end

# source://activesupport//lib/active_support/notifications/instrumenter.rb#22
class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#23
  def initialize(notifier); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#27
  def build_handle(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#31
  def finish(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#31
  def start(*_arg0, **_arg1, &_arg2); end
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#6
module ActiveSupport::Tryable
  # source://activesupport//lib/active_support/core_ext/object/try.rb#7
  def try(*args, **_arg1, &block); end

  # source://activesupport//lib/active_support/core_ext/object/try.rb#20
  def try!(*args, **_arg1, &block); end
end

# source://activesupport//lib/active_support/core_ext/array/extract_options.rb#14
class Array
  include ::Enumerable

  # Extracts options from a set of arguments. Removes and returns the last
  # element in the array if it's a hash, otherwise returns a blank hash.
  #
  #   def options(*args)
  #     args.extract_options!
  #   end
  #
  #   options(1, 2)        # => {}
  #   options(1, 2, a: :b) # => {:a=>:b}
  #
  # source://activesupport//lib/active_support/core_ext/array/extract_options.rb#24
  def extract_options!; end
end

# source://activesupport//lib/active_support/core_ext/class/attribute.rb#6
class Class < ::Module
  # Declare a class-level attribute whose value is inheritable by subclasses.
  # Subclasses can change their own value and it will not impact parent class.
  #
  # ==== Options
  #
  # * <tt>:instance_reader</tt> - Sets the instance reader method (defaults to true).
  # * <tt>:instance_writer</tt> - Sets the instance writer method (defaults to true).
  # * <tt>:instance_accessor</tt> - Sets both instance methods (defaults to true).
  # * <tt>:instance_predicate</tt> - Sets a predicate method (defaults to true).
  # * <tt>:default</tt> - Sets a default value for the attribute (defaults to nil).
  #
  # ==== Examples
  #
  #   class Base
  #     class_attribute :setting
  #   end
  #
  #   class Subclass < Base
  #   end
  #
  #   Base.setting = true
  #   Subclass.setting            # => true
  #   Subclass.setting = false
  #   Subclass.setting            # => false
  #   Base.setting                # => true
  #
  # In the above case as long as Subclass does not assign a value to setting
  # by performing <tt>Subclass.setting = _something_</tt>, <tt>Subclass.setting</tt>
  # would read value assigned to parent class. Once Subclass assigns a value then
  # the value assigned by Subclass would be returned.
  #
  # This matches normal Ruby method inheritance: think of writing an attribute
  # on a subclass as overriding the reader method. However, you need to be aware
  # when using +class_attribute+ with mutable structures as +Array+ or +Hash+.
  # In such cases, you don't want to do changes in place. Instead use setters:
  #
  #   Base.setting = []
  #   Base.setting                # => []
  #   Subclass.setting            # => []
  #
  #   # Appending in child changes both parent and child because it is the same object:
  #   Subclass.setting << :foo
  #   Base.setting               # => [:foo]
  #   Subclass.setting           # => [:foo]
  #
  #   # Use setters to not propagate changes:
  #   Base.setting = []
  #   Subclass.setting += [:foo]
  #   Base.setting               # => []
  #   Subclass.setting           # => [:foo]
  #
  # For convenience, an instance predicate method is defined as well.
  # To skip it, pass <tt>instance_predicate: false</tt>.
  #
  #   Subclass.setting?       # => false
  #
  # Instances may overwrite the class value in the same way:
  #
  #   Base.setting = true
  #   object = Base.new
  #   object.setting          # => true
  #   object.setting = false
  #   object.setting          # => false
  #   Base.setting            # => true
  #
  # To opt out of the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   object.setting          # => NoMethodError
  #   object.setting?         # => NoMethodError
  #
  # To opt out of the instance writer method, pass <tt>instance_writer: false</tt>.
  #
  #   object.setting = false  # => NoMethodError
  #
  # To opt out of both instance methods, pass <tt>instance_accessor: false</tt>.
  #
  # To set a default value for the attribute, pass <tt>default:</tt>, like so:
  #
  #   class_attribute :settings, default: {}
  #
  # source://activesupport//lib/active_support/core_ext/class/attribute.rb#86
  def class_attribute(*attrs, instance_accessor: T.unsafe(nil), instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_predicate: T.unsafe(nil), default: T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#117
class Delegator < ::BasicObject
  include ::ActiveSupport::Tryable
end

# source://activesupport//lib/active_support/core_ext/array/extract_options.rb#3
class Hash
  include ::Enumerable
  include ::ActiveSupport::DeepMergeable

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/hash/deep_merge.rb#40
  def deep_merge?(other); end

  # Removes the given keys from hash and returns it.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except!(:c) # => { a: true, b: false }
  #   hash             # => { a: true, b: false }
  #
  # source://activesupport//lib/active_support/core_ext/hash/except.rb#8
  def except!(*keys); end

  # Removes and returns the key/value pairs matching the given keys.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.extract!(:a, :b) # => {:a=>1, :b=>2}
  #   hash                  # => {:c=>3, :d=>4}
  #
  # source://activesupport//lib/active_support/core_ext/hash/slice.rb#24
  def extract!(*keys); end

  # By default, only instances of Hash itself are extractable.
  # Subclasses of Hash may implement this method and return
  # true to declare themselves as extractable. If a Hash
  # is extractable, Array#extract_options! pops it from
  # the Array when it is the last element of the Array.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/array/extract_options.rb#9
  def extractable_options?; end

  # Replaces the hash with only the given keys.
  # Returns a hash containing the removed key/value pairs.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.slice!(:a, :b)  # => {:c=>3, :d=>4}
  #   hash                 # => {:a=>1, :b=>2}
  #
  # source://activesupport//lib/active_support/core_ext/hash/slice.rb#10
  def slice!(*keys); end
end

# == Attribute Accessors per Thread
#
# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes, but does so on a per-thread basis.
#
# So the values are scoped within the Thread.current space under the class name
# of the module.
#
# Note that it can also be scoped per-fiber if +Rails.application.config.active_support.isolation_level+
# is set to +:fiber+.
#
# source://activesupport//lib/active_support/core_ext/module/delegation.rb#3
class Module
  # Provides a +delegate+ class method to easily expose contained objects'
  # public methods as your own.
  #
  # ==== Options
  # * <tt>:to</tt> - Specifies the target object name as a symbol or string
  # * <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix
  # * <tt>:allow_nil</tt> - If set to true, prevents a +ActiveSupport::DelegationError+
  #   from being raised
  # * <tt>:private</tt> - If set to true, changes method visibility to private
  #
  # The macro receives one or more method names (specified as symbols or
  # strings) and the name of the target object via the <tt>:to</tt> option
  # (also a symbol or string).
  #
  # Delegation is particularly useful with Active Record associations:
  #
  #   class Greeter < ActiveRecord::Base
  #     def hello
  #       'hello'
  #     end
  #
  #     def goodbye
  #       'goodbye'
  #     end
  #   end
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, to: :greeter
  #   end
  #
  #   Foo.new.hello   # => "hello"
  #   Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>
  #
  # Multiple delegates to the same target are allowed:
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, :goodbye, to: :greeter
  #   end
  #
  #   Foo.new.goodbye # => "goodbye"
  #
  # Methods can be delegated to instance variables, class variables, or constants
  # by providing them as a symbols:
  #
  #   class Foo
  #     CONSTANT_ARRAY = [0,1,2,3]
  #     @@class_array  = [4,5,6,7]
  #
  #     def initialize
  #       @instance_array = [8,9,10,11]
  #     end
  #     delegate :sum, to: :CONSTANT_ARRAY
  #     delegate :min, to: :@@class_array
  #     delegate :max, to: :@instance_array
  #   end
  #
  #   Foo.new.sum # => 6
  #   Foo.new.min # => 4
  #   Foo.new.max # => 11
  #
  # It's also possible to delegate a method to the class by using +:class+:
  #
  #   class Foo
  #     def self.hello
  #       "world"
  #     end
  #
  #     delegate :hello, to: :class
  #   end
  #
  #   Foo.new.hello # => "world"
  #
  # Delegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value
  # is <tt>true</tt>, the delegate methods are prefixed with the name of the object being
  # delegated to.
  #
  #   Person = Struct.new(:name, :address)
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: true
  #   end
  #
  #   john_doe = Person.new('John Doe', 'Vimmersvej 13')
  #   invoice = Invoice.new(john_doe)
  #   invoice.client_name    # => "John Doe"
  #   invoice.client_address # => "Vimmersvej 13"
  #
  # It is also possible to supply a custom prefix.
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: :customer
  #   end
  #
  #   invoice = Invoice.new(john_doe)
  #   invoice.customer_name    # => 'John Doe'
  #   invoice.customer_address # => 'Vimmersvej 13'
  #
  # The delegated methods are public by default.
  # Pass <tt>private: true</tt> to change that.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :first_name, to: :profile
  #     delegate :date_of_birth, to: :profile, private: true
  #
  #     def age
  #       Date.today.year - date_of_birth.year
  #     end
  #   end
  #
  #   User.new.first_name # => "Tomas"
  #   User.new.date_of_birth # => NoMethodError: private method `date_of_birth' called for #<User:0x00000008221340>
  #   User.new.age # => 2
  #
  # If the target is +nil+ and does not respond to the delegated method a
  # +ActiveSupport::DelegationError+ is raised. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile
  #   end
  #
  #   User.new.age
  #   # => ActiveSupport::DelegationError: User#age delegated to profile.age, but profile is nil
  #
  # But if not having a profile yet is fine and should not be an error
  # condition:
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile, allow_nil: true
  #   end
  #
  #   User.new.age # nil
  #
  # Note that if the target is not +nil+ then the call is attempted regardless of the
  # <tt>:allow_nil</tt> option, and thus an exception is still raised if said object
  # does not respond to the method:
  #
  #   class Foo
  #     def initialize(bar)
  #       @bar = bar
  #     end
  #
  #     delegate :name, to: :@bar, allow_nil: true
  #   end
  #
  #   Foo.new("Bar").name # raises NoMethodError: undefined method `name'
  #
  # The target method must be public, otherwise it will raise +NoMethodError+.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#160
  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  # When building decorators, a common pattern may emerge:
  #
  #   class Partition
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #
  #     private
  #       def respond_to_missing?(name, include_private = false)
  #         @event.respond_to?(name, include_private)
  #       end
  #
  #       def method_missing(method, *args, &block)
  #         @event.send(method, *args, &block)
  #       end
  #   end
  #
  # With <tt>Module#delegate_missing_to</tt>, the above is condensed to:
  #
  #   class Partition
  #     delegate_missing_to :@event
  #
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #   end
  #
  # The target can be anything callable within the object, e.g. instance
  # variables, methods, constants, etc.
  #
  # The delegated method must be public on the target, otherwise it will
  # raise +ActiveSupport::DelegationError+. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  # The <tt>marshal_dump</tt> and <tt>_dump</tt> methods are exempt from
  # delegation due to possible interference when calling
  # <tt>Marshal.dump(object)</tt>, should the delegation target method
  # of <tt>object</tt> add or remove instance variables.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#218
  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end

  # deprecate :foo, deprecator: MyLib.deprecator
  #   deprecate :foo, bar: "warning!", deprecator: MyLib.deprecator
  #
  # A deprecator is typically an instance of ActiveSupport::Deprecation, but you can also pass any object that responds
  # to <tt>deprecation_warning(deprecated_method_name, message, caller_backtrace)</tt> where you can implement your
  # custom warning behavior.
  #
  #   class MyLib::Deprecator
  #     def deprecation_warning(deprecated_method_name, message, caller_backtrace = nil)
  #       message = "#{deprecated_method_name} is deprecated and will be removed from MyLibrary | #{message}"
  #       Kernel.warn message
  #     end
  #   end
  #
  # source://activesupport//lib/active_support/core_ext/module/deprecation.rb#17
  def deprecate(*method_names, deprecator:, **options); end

  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#30
  def method_visibility(method); end

  # Replaces the existing method definition, if there is one, with the passed
  # block as its body.
  #
  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#17
  def redefine_method(method, &block); end

  # Replaces the existing singleton method definition, if there is one, with
  # the passed block as its body.
  #
  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#26
  def redefine_singleton_method(method, &block); end

  # Marks the named method as intended to be redefined, if it exists.
  # Suppresses the Ruby method redefinition warning. Prefer
  # #redefine_method where possible.
  #
  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#7
  def silence_redefinition_of_method(method); end
end

# source://activesupport//lib/active_support/core_ext/module/delegation.rb#5
Module::DelegationError = ActiveSupport::DelegationError

class NameError < ::StandardError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#137
class NilClass
  # Calling +try+ on +nil+ always returns +nil+.
  # It becomes especially helpful when navigating through associations that may return +nil+.
  #
  #   nil.try(:name) # => nil
  #
  # Without +try+
  #   @person && @person.children.any? && @person.children.first.name
  #
  # With +try+
  #   @person.try(:children).try(:first).try(:name)
  #
  # source://activesupport//lib/active_support/core_ext/object/try.rb#148
  def try(*_arg0, &_arg1); end

  # Calling +try!+ on +nil+ always returns +nil+.
  #
  #   nil.try!(:name) # => nil
  #
  # source://activesupport//lib/active_support/core_ext/object/try.rb#155
  def try!(*_arg0, &_arg1); end
end

# --
# Most objects are cloneable, but not all. For example you can't dup methods:
#
#   method(:puts).dup # => TypeError: allocator undefined for Method
#
# Classes may signal their instances are not duplicable removing +dup+/+clone+
# or raising exceptions from them. So, to dup an arbitrary object you normally
# use an optimistic approach and are ready to catch an exception, say:
#
#   arbitrary_object.dup rescue object
#
# Rails dups objects in a few critical spots where they are not that arbitrary.
# That rescue is very expensive (like 40 times slower than a predicate), and it
# is often triggered.
#
# That's why we hardcode the following cases and check duplicable? instead of
# using that rescue idiom.
# ++
#
# source://activesupport//lib/active_support/core_ext/object/try.rb#35
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::ActiveSupport::Tryable
end
