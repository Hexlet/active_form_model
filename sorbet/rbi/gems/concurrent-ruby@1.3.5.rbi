# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `concurrent-ruby` gem.
# Please instead update this file by running `bin/tapioca gem concurrent-ruby`.


# {include:file:README.md}
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#1
module Concurrent
  extend ::Concurrent::Utility::EngineDetector
end

# An abstract implementation of local storage, with sub-classes for
# per-thread and per-fiber locals.
#
# Each execution context (EC, thread or fiber) has a lazily initialized array
# of local variable values. Each time a new local variable is created, we
# allocate an "index" for it.
#
# For example, if the allocated index is 1, that means slot #1 in EVERY EC's
# locals array will be used for the value of that variable.
#
# The good thing about using a per-EC structure to hold values, rather than
# a global, is that no synchronization is needed when reading and writing
# those values (since the structure is only ever accessed by a single
# thread).
#
# Of course, when a local variable is GC'd, 1) we need to recover its index
# for use by other new local variables (otherwise the locals arrays could
# get bigger and bigger with time), and 2) we need to null out all the
# references held in the now-unused slots (both to avoid blocking GC of those
# objects, and also to prevent "stale" values from being passed on to a new
# local when the index is reused).
#
# Because we need to null out freed slots, we need to keep references to
# ALL the locals arrays, so we can null out the appropriate slots in all of
# them. This is why we need to use a finalizer to clean up the locals array
# when the EC goes out of scope.
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#35
class Concurrent::AbstractLocals
  # @return [AbstractLocals] a new instance of AbstractLocals
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#36
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#89
  def fetch(index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#71
  def free_index(index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#55
  def next_index(local); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#102
  def set(index, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#43
  def synchronize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#48
  def weak_synchronize; end

  private

  # When the local goes out of scope, clean up that slot across all locals currently assigned.
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#112
  def local_finalizer(index); end

  # Returns the locals for the current scope, or nil if none exist.
  #
  # @raise [NotImplementedError]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#128
  def locals; end

  # Returns the locals for the current scope, creating them if necessary.
  #
  # @raise [NotImplementedError]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#133
  def locals!; end

  # When a thread/fiber goes out of scope, remove the array from @all_arrays.
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#119
  def thread_fiber_finalizer(array_object_id); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#7
module Concurrent::Collection; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#10
Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#10
class Concurrent::Collection::MriMapBackend < ::Concurrent::Collection::NonConcurrentMapBackend
  # @return [MriMapBackend] a new instance of MriMapBackend
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#12
  def initialize(options = T.unsafe(nil), &default_proc); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#17
  def []=(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#61
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#33
  def compute(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#21
  def compute_if_absent(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#29
  def compute_if_present(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#53
  def delete(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#57
  def delete_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#49
  def get_and_set(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#37
  def merge_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#45
  def replace_if_exists(key, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#41
  def replace_pair(key, old_value, new_value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#9
class Concurrent::Collection::NonConcurrentMapBackend
  # WARNING: all public methods of the class must operate on the @backend
  # directly without calling each other. This is important because of the
  # SynchronizedMapBackend which uses a non-reentrant mutex for performance
  # reasons.
  #
  # @return [NonConcurrentMapBackend] a new instance of NonConcurrentMapBackend
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#15
  def initialize(options = T.unsafe(nil), &default_proc); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#21
  def [](key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#25
  def []=(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#94
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#59
  def compute(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#29
  def compute_if_absent(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#53
  def compute_if_present(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#81
  def delete(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#85
  def delete_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#99
  def each_pair; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#71
  def get_and_set(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#110
  def get_or_default(key, default_value); end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#77
  def key?(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#63
  def merge_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#46
  def replace_if_exists(key, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#37
  def replace_pair(key, old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#106
  def size; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#130
  def dupped_backend; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#124
  def initialize_copy(other); end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#134
  def pair?(key, expected_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#116
  def set_backend(default_proc); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#138
  def store_computed_value(key, new_value); end
end

# An array-backed storage of indexed variables per fiber.
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#166
class Concurrent::FiberLocals < ::Concurrent::AbstractLocals
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#167
  def locals; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#171
  def locals!; end
end

# `Concurrent::Map` is a hash-like object and should have much better performance
# characteristics, especially under high concurrency, than `Concurrent::Hash`.
# However, `Concurrent::Map `is not strictly semantically equivalent to a ruby `Hash`
# -- for instance, it does not necessarily retain ordering by insertion time as `Hash`
# does. For most uses it should do fine though, and we recommend you consider
# `Concurrent::Map` instead of `Concurrent::Hash` for your concurrency-safe hash needs.
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#39
class Concurrent::Map < ::Concurrent::Collection::MriMapBackend
  # Iterates over each key value pair.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key value pair in the map
  # @yieldparam key [Object]
  # @yieldparam value [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#274
  def each; end

  # Iterates over each key.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key in the map
  # @yieldparam key [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#255
  def each_key; end

  # Iterates over each key value pair.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key value pair in the map
  # @yieldparam key [Object]
  # @yieldparam value [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#274
  def each_pair; end

  # Iterates over each value.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each value in the map
  # @yieldparam value [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#264
  def each_value; end

  # Is map empty?
  #
  # @return [true, false]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#291
  def empty?; end

  # Get a value with key, or default_value when key is absent,
  # or fail when no default_value is given.
  #
  # @note The "fetch-then-act" methods of `Map` are not atomic. `Map` is intended
  #   to be use as a concurrency primitive with strong happens-before
  #   guarantees. It is not intended to be used as a high-level abstraction
  #   supporting complex operations. All read and write operations are
  #   thread safe, but no guarantees are made regarding race conditions
  #   between the fetch operation and yielding to the block. Additionally,
  #   this method does not support recursion. This is due to internal
  #   constraints that are very unlikely to change in the near future.
  # @param key [Object]
  # @param default_value [Object]
  # @raise [KeyError] when key is missing and no default_value is provided
  # @return [Object] the value or default value
  # @yield default value for a key
  # @yieldparam key [Object]
  # @yieldreturn [Object] default value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#183
  def fetch(key, default_value = T.unsafe(nil)); end

  # Fetch value with key, or store default value when key is absent,
  # or fail when no default_value is given. This is a two step operation,
  # therefore not atomic. The store can overwrite other concurrently
  # stored value.
  #
  # @param key [Object]
  # @param default_value [Object]
  # @return [Object] the value or default value
  # @yield default value for a key
  # @yieldparam key [Object]
  # @yieldreturn [Object] default value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#205
  def fetch_or_store(key, default_value = T.unsafe(nil)); end

  # Get a value with key
  #
  # @param key [Object]
  # @return [Object] the value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#21
  def get(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#321
  def inspect; end

  # Find key of a value.
  #
  # @param value [Object]
  # @return [Object, nil] key or nil when not found
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#284
  def key(value); end

  # All keys
  #
  # @return [::Array<Object>] keys
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#236
  def keys; end

  # @raise [TypeError]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#305
  def marshal_dump; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#313
  def marshal_load(hash); end

  # Set a value with key
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object] the new value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#17
  def put(key, value); end

  # Insert value into map with key if key is absent in one atomic step.
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object, nil] the previous value when key was present or nil when there was no key
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#215
  def put_if_absent(key, value); end

  # Is the value stored in the map. Iterates over all values.
  #
  # @param value [Object]
  # @return [true, false]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#227
  def value?(value); end

  # All values
  #
  # @return [::Array<Object>] values
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#244
  def values; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#331
  def initialize_copy(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#336
  def populate_from(hash); end

  # @raise [KeyError]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#327
  def raise_fetch_no_key; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#341
  def validate_options_hash!(options); end
end

# Various classes within allows for +nil+ values to be stored,
# so a special +NULL+ token is required to indicate the "nil-ness".
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#6
Concurrent::NULL = T.let(T.unsafe(nil), Object)

# A `ThreadLocalVar` is a variable where the value is different for each thread.
# Each variable may have a default value, but when you modify the variable only
# the current thread will ever see that change.
#
# This is similar to Ruby's built-in thread-local variables (`Thread#thread_variable_get`),
# but with these major advantages:
# * `ThreadLocalVar` has its own identity, it doesn't need a Symbol.
# * Each Ruby's built-in thread-local variable leaks some memory forever (it's a Symbol held forever on the thread),
#   so it's only OK to create a small amount of them.
#   `ThreadLocalVar` has no such issue and it is fine to create many of them.
# * Ruby's built-in thread-local variables leak forever the value set on each thread (unless set to nil explicitly).
#   `ThreadLocalVar` automatically removes the mapping for each thread once the `ThreadLocalVar` instance is GC'd.
#
#
# ## Thread-safe Variable Classes
#
# Each of the thread-safe variable classes is designed to solve a different
# problem. In general:
#
# * *{Concurrent::Agent}:* Shared, mutable variable providing independent,
#   uncoordinated, *asynchronous* change of individual values. Best used when
#   the value will undergo frequent, complex updates. Suitable when the result
#   of an update does not need to be known immediately.
# * *{Concurrent::Atom}:* Shared, mutable variable providing independent,
#   uncoordinated, *synchronous* change of individual values. Best used when
#   the value will undergo frequent reads but only occasional, though complex,
#   updates. Suitable when the result of an update must be known immediately.
# * *{Concurrent::AtomicReference}:* A simple object reference that can be updated
#   atomically. Updates are synchronous but fast. Best used when updates a
#   simple set operations. Not suitable when updates are complex.
#   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar
#   but optimized for the given data type.
# * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used
#   when two or more threads need to exchange data. The threads will pair then
#   block on each other until the exchange is complete.
# * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread
#   must give a value to another, which must take the value. The threads will
#   block on each other until the exchange is complete.
# * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which
#   holds a different value for each thread which has access. Often used as
#   an instance variable in objects which must maintain different state
#   for different threads.
# * *{Concurrent::TVar}:* Shared, mutable variables which provide
#   *coordinated*, *synchronous*, change of *many* stated. Used when multiple
#   value must change together, in an all-or-nothing transaction.
#
# @example
#   v = ThreadLocalVar.new(14)
#   v.value #=> 14
#   v.value = 2
#   v.value #=> 2
# @example
#   v = ThreadLocalVar.new(14)
#
#   t1 = Thread.new do
#   v.value #=> 14
#   v.value = 1
#   v.value #=> 1
#   end
#
#   t2 = Thread.new do
#   v.value #=> 14
#   v.value = 2
#   v.value #=> 2
#   end
#
#   v.value #=> 14
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#43
class Concurrent::ThreadLocalVar
  # Creates a thread local variable.
  #
  # @param default [Object] the default value when otherwise unset
  # @param default_block [Proc] Optional block that gets called to obtain the
  #   default value for each thread
  # @return [ThreadLocalVar] a new instance of ThreadLocalVar
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#51
  def initialize(default = T.unsafe(nil), &default_block); end

  # Bind the given value to thread local storage during
  # execution of the given block.
  #
  # @param value [Object] the value to bind
  # @return [Object] the value
  # @yield the operation to be performed with the bound variable
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#88
  def bind(value); end

  # Returns the value in the current thread's copy of this thread-local variable.
  #
  # @return [Object] the current value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#70
  def value; end

  # Sets the current thread's copy of this thread-local variable to the specified value.
  #
  # @param value [Object] the value to set
  # @return [Object] the new value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#78
  def value=(value); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#103
  def default; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#44
Concurrent::ThreadLocalVar::LOCALS = T.let(T.unsafe(nil), Concurrent::ThreadLocals)

# An array-backed storage of indexed variables per thread.
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#141
class Concurrent::ThreadLocals < ::Concurrent::AbstractLocals
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#142
  def locals; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#146
  def locals!; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#3
module Concurrent::Utility; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#6
module Concurrent::Utility::EngineDetector
  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#7
  def on_cruby?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#11
  def on_jruby?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#27
  def on_linux?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#23
  def on_osx?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#15
  def on_truffleruby?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#19
  def on_windows?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#31
  def ruby_version(version = T.unsafe(nil), comparison, major, minor, patch); end
end
